(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('worker-factory')) :
    typeof define === 'function' && define.amd ? define(['worker-factory'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.workerFactory));
})(this, (function (workerFactory) { 'use strict';

    var createCreateOrUpdateRecording = function createCreateOrUpdateRecording(recordings) {
      return function (recordingId, sampleRate, typedArrays) {
        var recording = recordings.get(recordingId);
        if (recording === undefined) {
          var newRecording = {
            channelDataArrays: typedArrays.map(function (typedArray) {
              return [typedArray];
            }),
            isComplete: true,
            sampleRate: sampleRate
          };
          recordings.set(recordingId, newRecording);
          return newRecording;
        }
        // @todo Check if the given sampleRate is the same as the one of the recording.
        recording.channelDataArrays.forEach(function (channelDataArray, index) {
          return channelDataArray.push(typedArrays[index]);
        });
        return recording;
      };
    };

    var createEncode = function createEncode(computeNumberOfSamples, encodeHeader) {
      return function (channelDataArrays, part, bitRate, sampleRate) {
        var bytesPerSample = bitRate >> 3; // tslint:disable-line:no-bitwise
        var headerSize = part === 'subsequent' ? 0 : 44;
        var numberOfChannels = channelDataArrays.length;
        var numberOfSamples = computeNumberOfSamples(channelDataArrays[0]);
        var arrayBuffer = new ArrayBuffer(numberOfSamples * numberOfChannels * bytesPerSample + headerSize);
        var dataView = new DataView(arrayBuffer);
        if (part !== 'subsequent') {
          encodeHeader(dataView, bitRate, numberOfChannels, part === 'complete' ? numberOfSamples : Number.POSITIVE_INFINITY, sampleRate);
        }
        channelDataArrays.forEach(function (channel, index) {
          var offset = headerSize + index * bytesPerSample;
          channel.forEach(function (channelDataArray) {
            var length = channelDataArray.length;
            for (var i = 0; i < length; i += 1) {
              var value = channelDataArray[i];
              dataView.setInt16(offset, value < 0 ? Math.max(-1, value) * 32768 : Math.min(1, value) * 32767, true);
              offset += numberOfChannels * bytesPerSample;
            }
          });
        });
        return [arrayBuffer];
      };
    };

    var computeNumberOfSamples = function computeNumberOfSamples(channelDataArray) {
      return channelDataArray.reduce(function (length, channelData) {
        return length + channelData.length;
      }, 0);
    };

    var encodeHeader = function encodeHeader(dataView, bitRate, numberOfChannels, numberOfSamples, sampleRate) {
      var bytesPerSample = bitRate >> 3; // tslint:disable-line:no-bitwise
      /*
       * The maximum size of a RIFF file is 4294967295 bytes and since the header takes up 44 bytes there are 4294967251 bytes left for the
       * data chunk.
       */
      var dataChunkSize = Math.min(numberOfSamples * numberOfChannels * bytesPerSample, 4294967251);
      dataView.setUint32(0, 1380533830); // That's the integer representation of 'RIFF'.
      dataView.setUint32(4, dataChunkSize + 36, true);
      dataView.setUint32(8, 1463899717); // That's the integer representation of 'WAVE'.
      dataView.setUint32(12, 1718449184); // That's the integer representation of 'fmt '.
      dataView.setUint32(16, 16, true);
      dataView.setUint16(20, 1, true);
      dataView.setUint16(22, numberOfChannels, true);
      dataView.setUint32(24, sampleRate, true);
      dataView.setUint32(28, sampleRate * numberOfChannels * bytesPerSample, true);
      dataView.setUint16(32, numberOfChannels * bytesPerSample, true);
      dataView.setUint16(34, bitRate, true);
      dataView.setUint32(36, 1684108385); // That's the integer representation of 'data'.
      dataView.setUint32(40, dataChunkSize, true);
    };

    var shiftChannelDataArrays = function shiftChannelDataArrays(channelDataArrays, numberOfSamples) {
      var shiftedChannelDataArrays = [];
      var numberOfShiftedSamples = 0;
      shiftChannelDataArrays: while (numberOfShiftedSamples < numberOfSamples) {
        var length = channelDataArrays.length;
        for (var i = 0; i < length; i += 1) {
          var channelDataArray = channelDataArrays[i];
          if (shiftedChannelDataArrays[i] === undefined) {
            shiftedChannelDataArrays[i] = [];
          }
          var channelData = channelDataArray.shift();
          if (channelData === undefined) {
            break shiftChannelDataArrays;
          }
          shiftedChannelDataArrays[i].push(channelData);
          if (i === 0) {
            numberOfShiftedSamples += channelData.length;
          }
        }
      }
      if (numberOfShiftedSamples > numberOfSamples) {
        var unnecessarySamples = numberOfShiftedSamples - numberOfSamples;
        shiftedChannelDataArrays.forEach(function (shiftedChannelDataArray, index) {
          var channelData = shiftedChannelDataArray.pop();
          var offset = channelData.length - unnecessarySamples;
          shiftedChannelDataArray.push(channelData.subarray(0, offset));
          channelDataArrays[index].unshift(channelData.subarray(offset));
        });
      }
      return shiftedChannelDataArrays;
    };

    var recordings = new Map();
    var createOrUpdateRecording = createCreateOrUpdateRecording(recordings);
    var _encode = createEncode(computeNumberOfSamples, encodeHeader);
    var encodings = new Map();
    workerFactory.createWorker(self, {
      characterize: function characterize() {
        return {
          result: /^audio\/wav$/
        };
      },
      encode: function encode(_ref) {
        var recordingId = _ref.recordingId,
          timeslice = _ref.timeslice;
        var encoding = encodings.get(recordingId);
        if (encoding !== undefined) {
          encodings["delete"](recordingId);
          encoding.reject(new Error('Another request was made to initiate an encoding.'));
        }
        var recording = recordings.get(recordingId);
        if (timeslice !== null) {
          if (recording === undefined || computeNumberOfSamples(recording.channelDataArrays[0]) * (1000 / recording.sampleRate) < timeslice) {
            return new Promise(function (resolve, reject) {
              encodings.set(recordingId, {
                reject: reject,
                resolve: resolve,
                timeslice: timeslice
              });
            });
          }
          var shiftedChannelDataArrays = shiftChannelDataArrays(recording.channelDataArrays, Math.ceil(timeslice * (recording.sampleRate / 1000)));
          var arrayBuffers = _encode(shiftedChannelDataArrays, recording.isComplete ? 'initial' : 'subsequent', 16, recording.sampleRate);
          recording.isComplete = false;
          return {
            result: arrayBuffers,
            transferables: arrayBuffers
          };
        }
        if (recording !== undefined) {
          var _arrayBuffers = _encode(recording.channelDataArrays, recording.isComplete ? 'complete' : 'subsequent', 16, recording.sampleRate);
          recordings["delete"](recordingId);
          return {
            result: _arrayBuffers,
            transferables: _arrayBuffers
          };
        }
        return {
          result: [],
          transferables: []
        };
      },
      record: function record(_ref2) {
        var recordingId = _ref2.recordingId,
          sampleRate = _ref2.sampleRate,
          typedArrays = _ref2.typedArrays;
        var recording = createOrUpdateRecording(recordingId, sampleRate, typedArrays);
        var encoding = encodings.get(recordingId);
        if (encoding !== undefined && computeNumberOfSamples(recording.channelDataArrays[0]) * (1000 / sampleRate) >= encoding.timeslice) {
          var shiftedChannelDataArrays = shiftChannelDataArrays(recording.channelDataArrays, Math.ceil(encoding.timeslice * (sampleRate / 1000)));
          var arrayBuffers = _encode(shiftedChannelDataArrays, recording.isComplete ? 'initial' : 'subsequent', 16, sampleRate);
          recording.isComplete = false;
          encodings["delete"](recordingId);
          encoding.resolve({
            result: arrayBuffers,
            transferables: arrayBuffers
          });
        }
        return {
          result: null
        };
      }
    });

}));
