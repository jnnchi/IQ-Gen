(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(require('@babel/runtime/helpers/asyncToGenerator'), require('@babel/runtime/regenerator'), require('worker-factory'), require('@babel/runtime/helpers/slicedToArray'), require('extendable-media-recorder-wav-encoder-broker')) :
    typeof define === 'function' && define.amd ? define(['@babel/runtime/helpers/asyncToGenerator', '@babel/runtime/regenerator', 'worker-factory', '@babel/runtime/helpers/slicedToArray', 'extendable-media-recorder-wav-encoder-broker'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global._asyncToGenerator, global._regeneratorRuntime, global.workerFactory, global._slicedToArray, global.extendableMediaRecorderWavEncoderBroker));
})(this, (function (_asyncToGenerator, _regeneratorRuntime, workerFactory, _slicedToArray, extendableMediaRecorderWavEncoderBroker) { 'use strict';

    var createFinishEncoding = function createFinishEncoding(closePort, removeEncoderInstance) {
      return function (encoderId) {
        var _removeEncoderInstanc = removeEncoderInstance(encoderId),
          _removeEncoderInstanc2 = _slicedToArray(_removeEncoderInstanc, 4),
          encoderBroker = _removeEncoderInstanc2[0],
          port = _removeEncoderInstanc2[1],
          isRecording = _removeEncoderInstanc2[2],
          sampleRate = _removeEncoderInstanc2[3];
        if (!isRecording) {
          return encoderBroker.encode(encoderId, null);
        }
        return new Promise(function (resolve) {
          port.onmessage = function (_ref) {
            var data = _ref.data;
            if (data.length === 0) {
              closePort(port);
              resolve(encoderBroker.encode(encoderId, null));
            } else {
              encoderBroker.record(encoderId, sampleRate, data);
            }
          };
        });
      };
    };

    var createGetEncoderInstance = function createGetEncoderInstance(encoderInstancesRegistry) {
      return function (encoderId) {
        var entry = encoderInstancesRegistry.get(encoderId);
        if (entry === undefined) {
          throw new Error('There was no instance of an encoder stored with the given id.');
        }
        return entry;
      };
    };

    var createInstantiateEncoder = function createInstantiateEncoder(closePort, encoderInstancesRegistry, pickCapableEncoderBroker) {
      return function (encoderId, mimeType, sampleRate) {
        if (encoderInstancesRegistry.has(encoderId)) {
          throw new Error("There is already an encoder registered with an id called \"".concat(encoderId, "\"."));
        }
        var encoderBroker = pickCapableEncoderBroker(mimeType);
        var _MessageChannel = new MessageChannel(),
          port1 = _MessageChannel.port1,
          port2 = _MessageChannel.port2;
        var entry = [encoderBroker, port1, true, sampleRate];
        encoderInstancesRegistry.set(encoderId, entry);
        port1.onmessage = function (_ref) {
          var data = _ref.data;
          if (data.length === 0) {
            closePort(port1);
            entry[2] = false;
          } else {
            encoderBroker.record(encoderId, sampleRate, data.map(function (channelDataOrNumberOfSamples) {
              return typeof channelDataOrNumberOfSamples === 'number' ? new Float32Array(channelDataOrNumberOfSamples) : channelDataOrNumberOfSamples;
            }));
          }
        };
        return port2;
      };
    };

    var createPickCapableEncoderBroker = function createPickCapableEncoderBroker(encoderBrokerRegistry) {
      return function (mimeType) {
        for (var _i = 0, _Array$from = Array.from(encoderBrokerRegistry.values()); _i < _Array$from.length; _i++) {
          var _Array$from$_i = _slicedToArray(_Array$from[_i], 2),
            regex = _Array$from$_i[0],
            encoderBroker = _Array$from$_i[1];
          if (regex.test(mimeType)) {
            return encoderBroker;
          }
        }
        throw new Error('There is no encoder registered which could handle the given mimeType.');
      };
    };

    var createRemoveEncoderInstance = function createRemoveEncoderInstance(encoderInstancesRegistry, getEncoderInstance) {
      return function (encoderId) {
        var entry = getEncoderInstance(encoderId);
        encoderInstancesRegistry["delete"](encoderId);
        return entry;
      };
    };

    var createRequestPartialEncoding = function createRequestPartialEncoding(getEncoderInstance) {
      return function (encoderId, timeslice) {
        var _getEncoderInstance = getEncoderInstance(encoderId),
          _getEncoderInstance2 = _slicedToArray(_getEncoderInstance, 1),
          encoderBroker = _getEncoderInstance2[0];
        return encoderBroker.encode(encoderId, timeslice);
      };
    };

    var closePort = function closePort(port) {
      port.onmessage = null;
      port.close();
    };

    var registerEncoder = /*#__PURE__*/function () {
      var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(encoderBrokerRegistry, port) {
        var encoderBroker, regex, regexAsString;
        return _regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              encoderBroker = extendableMediaRecorderWavEncoderBroker.wrap(port);
              _context.next = 3;
              return encoderBroker.characterize();
            case 3:
              regex = _context.sent;
              regexAsString = regex.toString();
              if (!encoderBrokerRegistry.has(regexAsString)) {
                _context.next = 7;
                break;
              }
              throw new Error('There is already an encoder stored which handles exactly the same mime types.');
            case 7:
              encoderBrokerRegistry.set(regexAsString, [regex, encoderBroker]);
              return _context.abrupt("return", regex);
            case 9:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return function registerEncoder(_x, _x2) {
        return _ref.apply(this, arguments);
      };
    }();

    var encoderInstancesRegistry = new Map();
    var getEncoderInstance = createGetEncoderInstance(encoderInstancesRegistry);
    var removeEncoderInstance = createRemoveEncoderInstance(encoderInstancesRegistry, getEncoderInstance);
    var encoderBrokerRegistry = new Map();
    var finishEncoding = createFinishEncoding(closePort, removeEncoderInstance);
    var pickCapableEncoderBroker = createPickCapableEncoderBroker(encoderBrokerRegistry);
    var instantiateEncoder = createInstantiateEncoder(closePort, encoderInstancesRegistry, pickCapableEncoderBroker);
    var requestPartialEncoding = createRequestPartialEncoding(getEncoderInstance);
    workerFactory.createWorker(self, {
      encode: function () {
        var _encode = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(_ref) {
          var encoderId, timeslice, arrayBuffers;
          return _regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) switch (_context.prev = _context.next) {
              case 0:
                encoderId = _ref.encoderId, timeslice = _ref.timeslice;
                if (!(timeslice === null)) {
                  _context.next = 7;
                  break;
                }
                _context.next = 4;
                return finishEncoding(encoderId);
              case 4:
                _context.t0 = _context.sent;
                _context.next = 10;
                break;
              case 7:
                _context.next = 9;
                return requestPartialEncoding(encoderId, timeslice);
              case 9:
                _context.t0 = _context.sent;
              case 10:
                arrayBuffers = _context.t0;
                return _context.abrupt("return", {
                  result: arrayBuffers,
                  transferables: arrayBuffers
                });
              case 12:
              case "end":
                return _context.stop();
            }
          }, _callee);
        }));
        function encode(_x) {
          return _encode.apply(this, arguments);
        }
        return encode;
      }(),
      instantiate: function instantiate(_ref2) {
        var encoderId = _ref2.encoderId,
          mimeType = _ref2.mimeType,
          sampleRate = _ref2.sampleRate;
        var port = instantiateEncoder(encoderId, mimeType, sampleRate);
        return {
          result: port,
          transferables: [port]
        };
      },
      register: function () {
        var _register = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(_ref3) {
          var port;
          return _regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) switch (_context2.prev = _context2.next) {
              case 0:
                port = _ref3.port;
                _context2.next = 3;
                return registerEncoder(encoderBrokerRegistry, port);
              case 3:
                _context2.t0 = _context2.sent;
                return _context2.abrupt("return", {
                  result: _context2.t0
                });
              case 5:
              case "end":
                return _context2.stop();
            }
          }, _callee2);
        }));
        function register(_x2) {
          return _register.apply(this, arguments);
        }
        return register;
      }()
    });

}));
