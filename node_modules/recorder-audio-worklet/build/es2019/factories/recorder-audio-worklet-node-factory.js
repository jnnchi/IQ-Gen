export const createRecorderAudioWorkletNodeFactory = (createListener, createPostMessage, on, validateState) => {
    return (audioWorkletNodeConstructor, context, options = {}) => {
        const audioWorkletNode = new audioWorkletNodeConstructor(context, 'recorder-audio-worklet-processor', {
            ...options,
            channelCountMode: 'explicit',
            numberOfInputs: 1,
            numberOfOutputs: 0
        });
        const ongoingRequests = new Map();
        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);
        const unsubscribe = on(audioWorkletNode.port, 'message')(createListener(ongoingRequests));
        audioWorkletNode.port.start();
        let state = 'inactive';
        Object.defineProperties(audioWorkletNode, {
            pause: {
                get() {
                    return async () => {
                        validateState(['recording'], state);
                        state = 'paused';
                        return postMessage({
                            method: 'pause'
                        });
                    };
                }
            },
            port: {
                get() {
                    throw new Error("The port of a RecorderAudioWorkletNode can't be accessed.");
                }
            },
            record: {
                get() {
                    return async (encoderPort) => {
                        validateState(['inactive'], state);
                        state = 'recording';
                        return postMessage({
                            method: 'record',
                            params: { encoderPort }
                        }, [encoderPort]);
                    };
                }
            },
            resume: {
                get() {
                    return async () => {
                        validateState(['paused'], state);
                        state = 'recording';
                        return postMessage({
                            method: 'resume'
                        });
                    };
                }
            },
            stop: {
                get() {
                    return async () => {
                        validateState(['paused', 'recording'], state);
                        state = 'stopped';
                        try {
                            await postMessage({ method: 'stop' });
                        }
                        finally {
                            unsubscribe();
                        }
                    };
                }
            }
        });
        return audioWorkletNode;
    };
};
//# sourceMappingURL=recorder-audio-worklet-node-factory.js.map