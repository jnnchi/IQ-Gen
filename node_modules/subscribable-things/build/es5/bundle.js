(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('rxjs-interop'), require('@babel/runtime/helpers/defineProperty')) :
    typeof define === 'function' && define.amd ? define(['exports', 'rxjs-interop', '@babel/runtime/helpers/defineProperty'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.subscribableThings = {}, global.rxjsInterop, global._defineProperty));
})(this, (function (exports, rxjsInterop, _defineProperty) { 'use strict';

    var createAnimationFrame = function createAnimationFrame(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function () {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.cancelAnimationFrame === undefined || window.requestAnimationFrame === undefined) {
            return emitNotSupportedError(observer);
          }
          var animationFrameHandle = window.requestAnimationFrame(function animationFrameCallback(timestamp) {
            animationFrameHandle = window.requestAnimationFrame(animationFrameCallback);
            observer.next(timestamp);
          });
          return function () {
            return window.cancelAnimationFrame(animationFrameHandle);
          };
        });
      };
    };

    var createAttribute = function createAttribute(mapSubscribableThing, mutations, prependSubscribableThing) {
      return function (htmlElement, name) {
        var getAttribute = function getAttribute() {
          return htmlElement.getAttribute(name);
        };
        return prependSubscribableThing(mapSubscribableThing(mutations(htmlElement, {
          attributeFilter: [name],
          childList: false,
          subtree: false
        }), function () {
          return getAttribute();
        }), getAttribute());
      };
    };

    var createGeolocation = function createGeolocation(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.geolocation === undefined || window.navigator.geolocation.clearWatch === undefined || window.navigator.geolocation.watchPosition === undefined) {
            return emitNotSupportedError(observer);
          }
          var watchId = window.navigator.geolocation.watchPosition(function (position) {
            return observer.next(position);
          }, function (err) {
            return observer.error(err);
          }, options);
          return function () {
            return window.navigator.geolocation.clearWatch(watchId);
          };
        });
      };
    };

    var createIntersections = function createIntersections(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (htmlElement, options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.IntersectionObserver === undefined) {
            return emitNotSupportedError(observer);
          }
          var intersectionObserverObserver = new window.IntersectionObserver(function (entries) {
            return observer.next(entries);
          }, options);
          try {
            intersectionObserverObserver.observe(htmlElement);
          } catch (err) {
            observer.error(err);
          }
          return function () {
            return intersectionObserverObserver.disconnect();
          };
        });
      };
    };

    function ownKeys$1(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
    function _objectSpread$1(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys$1(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
    var createMapSubscribableThing = function createMapSubscribableThing(wrapSubscribeFunction) {
      return function (subscribableThing, map) {
        return wrapSubscribeFunction(function (observer) {
          return subscribableThing(_objectSpread$1(_objectSpread$1({}, observer), {}, {
            next: function next(value) {
              return observer.next(map(value));
            }
          }));
        });
      };
    };

    var createMediaDevices = function createMediaDevices(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function () {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.mediaDevices === undefined || window.navigator.mediaDevices.enumerateDevices === undefined) {
            return emitNotSupportedError(observer);
          }
          var isActive = true;
          var enumerateDevices = function enumerateDevices() {
            window.navigator.mediaDevices.enumerateDevices().then(function (mediaDevices) {
              if (isActive) {
                observer.next(mediaDevices);
              }
            }, function (err) {
              if (isActive) {
                unsubscribe();
                observer.error(err);
              }
            });
          };
          var unsubscribe = function unsubscribe() {
            isActive = false;
            window.navigator.mediaDevices.removeEventListener('devicechange', enumerateDevices);
          };
          enumerateDevices();
          window.navigator.mediaDevices.addEventListener('devicechange', enumerateDevices);
          return unsubscribe;
        });
      };
    };

    var createMediaQueryMatch = function createMediaQueryMatch(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (mediaQueryString) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.matchMedia === undefined) {
            return emitNotSupportedError(observer);
          }
          var mediaQueryList = window.matchMedia(mediaQueryString);
          observer.next(mediaQueryList.matches);
          mediaQueryList.onchange = function () {
            return observer.next(mediaQueryList.matches);
          };
          return function () {
            mediaQueryList.onchange = null;
          };
        });
      };
    };

    var createMetrics = function createMetrics(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.PerformanceObserver === undefined) {
            return emitNotSupportedError(observer);
          }
          var performanceObserver = new window.PerformanceObserver(function (entryList) {
            return observer.next(entryList.getEntries());
          });
          try {
            performanceObserver.observe(options);
          } catch (err) {
            observer.error(err);
          }
          return function () {
            return performanceObserver.disconnect();
          };
        });
      };
    };

    var createMidiInputs = function createMidiInputs(wrapSubscribeFunction) {
      return function (midiAccess) {
        return wrapSubscribeFunction(function (observer) {
          var midiInputs = Array.from(midiAccess.inputs.values());
          var emitMidiInputs = function emitMidiInputs() {
            var midiAccessInputs = midiAccess.inputs;
            if (midiInputs.length !== midiAccessInputs.size || midiInputs.some(function (_ref) {
              var id = _ref.id;
              return !midiAccessInputs.has(id);
            })) {
              midiInputs = Array.from(midiAccessInputs.values());
              observer.next(midiInputs);
            }
          };
          observer.next(midiInputs);
          midiAccess.addEventListener('statechange', emitMidiInputs);
          return function () {
            return midiAccess.removeEventListener('statechange', emitMidiInputs);
          };
        });
      };
    };

    var createMidiOutputs = function createMidiOutputs(wrapSubscribeFunction) {
      return function (midiAccess) {
        return wrapSubscribeFunction(function (observer) {
          var midiOutputs = Array.from(midiAccess.outputs.values());
          var emitMidiOutputs = function emitMidiOutputs() {
            var midiAccessOutputs = midiAccess.outputs;
            if (midiOutputs.length !== midiAccessOutputs.size || midiOutputs.some(function (_ref) {
              var id = _ref.id;
              return !midiAccessOutputs.has(id);
            })) {
              midiOutputs = Array.from(midiAccessOutputs.values());
              observer.next(midiOutputs);
            }
          };
          observer.next(midiOutputs);
          midiAccess.addEventListener('statechange', emitMidiOutputs);
          return function () {
            return midiAccess.removeEventListener('statechange', emitMidiOutputs);
          };
        });
      };
    };

    var createMutations = function createMutations(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (htmlElement, options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.MutationObserver === undefined) {
            return emitNotSupportedError(observer);
          }
          var mutationObserver = new window.MutationObserver(function (records) {
            return observer.next(records);
          });
          try {
            mutationObserver.observe(htmlElement, options);
          } catch (err) {
            observer.error(err);
          }
          return function () {
            return mutationObserver.disconnect();
          };
        });
      };
    };

    var createOn = function createOn(wrapSubscribeFunction) {
      return function (target, type, options) {
        return wrapSubscribeFunction(function (observer) {
          var listener = function listener(event) {
            return observer.next(event);
          };
          target.addEventListener(type, listener, options);
          return function () {
            return target.removeEventListener(type, listener, options);
          };
        });
      };
    };

    var createOnline = function createOnline(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function () {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.onLine === undefined) {
            return emitNotSupportedError(observer);
          }
          var emitFalse = function emitFalse() {
            return observer.next(false);
          };
          var emitTrue = function emitTrue() {
            return observer.next(true);
          };
          window.addEventListener('offline', emitFalse);
          window.addEventListener('online', emitTrue);
          observer.next(window.navigator.onLine);
          return function () {
            window.removeEventListener('offline', emitFalse);
            window.removeEventListener('online', emitTrue);
          };
        });
      };
    };

    var createPermissionState = function createPermissionState(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (permissionDescriptor) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.permissions === undefined || window.navigator.permissions.query === undefined) {
            return emitNotSupportedError(observer);
          }
          var isActive = true;
          var unsubscribe = function unsubscribe() {
            isActive = false;
          };
          window.navigator.permissions.query(permissionDescriptor).then(function (permissionStatus) {
            if (isActive) {
              observer.next(permissionStatus.state);
            }
            if (isActive) {
              permissionStatus.onchange = function () {
                return observer.next(permissionStatus.state);
              };
              unsubscribe = function unsubscribe() {
                permissionStatus.onchange = null;
              };
            }
          }, function (err) {
            if (isActive) {
              observer.error(err);
            }
          });
          return function () {
            return unsubscribe();
          };
        });
      };
    };

    var createPrependSubscribableThing = function createPrependSubscribableThing(wrapSubscribeFunction) {
      return function (subscribableThing, prependedValue) {
        return wrapSubscribeFunction(function (observer) {
          observer.next(prependedValue);
          return subscribableThing(observer);
        });
      };
    };

    var createReports = function createReports(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.ReportingObserver === undefined) {
            return emitNotSupportedError(observer);
          }
          var reportingObserver = new window.ReportingObserver(function (reportList) {
            return observer.next(reportList);
          }, options);
          reportingObserver.observe();
          return function () {
            return reportingObserver.disconnect();
          };
        });
      };
    };

    var createResizes = function createResizes(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (htmlElement, options) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.ResizeObserver === undefined) {
            return emitNotSupportedError(observer);
          }
          var resizeObserver = new window.ResizeObserver(function (entries) {
            return observer.next(entries);
          });
          try {
            resizeObserver.observe(htmlElement, options);
          } catch (err) {
            observer.error(err);
          }
          return function () {
            return resizeObserver.disconnect();
          };
        });
      };
    };

    var createUnhandledRejection = function createUnhandledRejection(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (coolingOffPeriod) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.clearInterval === undefined || window.setInterval === undefined) {
            return emitNotSupportedError(observer);
          }
          var possiblyUnhandledRejections = new Map();
          var intervalId = null;
          var deletePossiblyUnhandledRejection = function deletePossiblyUnhandledRejection(_ref) {
            var promise = _ref.promise;
            return possiblyUnhandledRejections["delete"](promise);
          };
          var emitUnhandledRejection = function emitUnhandledRejection() {
            var latestTimestampToEmit = Date.now() - coolingOffPeriod;
            possiblyUnhandledRejections.forEach(function (_ref2, promise) {
              var reason = _ref2.reason,
                timestamp = _ref2.timestamp;
              if (timestamp > latestTimestampToEmit) {
                return;
              }
              possiblyUnhandledRejections["delete"](promise);
              observer.next(reason);
            });
            if (intervalId !== null && possiblyUnhandledRejections.size === 0) {
              window.clearInterval(intervalId);
              intervalId = null;
            }
          };
          var registerPossiblyUnhandledRejection = function registerPossiblyUnhandledRejection(event) {
            event.preventDefault();
            possiblyUnhandledRejections.set(event.promise, {
              reason: event.reason,
              timestamp: Date.now()
            });
            if (intervalId === null) {
              intervalId = window.setInterval(emitUnhandledRejection, coolingOffPeriod / 2);
            }
          };
          window.addEventListener('rejectionhandled', deletePossiblyUnhandledRejection);
          window.addEventListener('unhandledrejection', registerPossiblyUnhandledRejection);
          return function () {
            if (intervalId !== null) {
              window.clearInterval(intervalId);
            }
            window.removeEventListener('rejectionhandled', deletePossiblyUnhandledRejection);
            window.removeEventListener('unhandledrejection', registerPossiblyUnhandledRejection);
          };
        });
      };
    };

    function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
    function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
    var createVideoFrame = function createVideoFrame(emitNotSupportedError, wrapSubscribeFunction) {
      return function (videoElement) {
        return wrapSubscribeFunction(function (observer) {
          if (videoElement.cancelVideoFrameCallback === undefined || videoElement.requestVideoFrameCallback === undefined) {
            return emitNotSupportedError(observer);
          }
          var videoFrameHandle = videoElement.requestVideoFrameCallback(function videoFrameCallback(now, metadata) {
            videoFrameHandle = videoElement.requestVideoFrameCallback(videoFrameCallback);
            observer.next(_objectSpread(_objectSpread({}, metadata), {}, {
              now: now
            }));
          });
          return function () {
            return videoElement.cancelVideoFrameCallback(videoFrameHandle);
          };
        });
      };
    };

    var createWakeLock = function createWakeLock(emitNotSupportedError, window, wrapSubscribeFunction) {
      return function (type) {
        return wrapSubscribeFunction(function (observer) {
          if (window === null || window.navigator === undefined || window.navigator.wakeLock === undefined) {
            return emitNotSupportedError(observer);
          }
          var releaseWakeLock = function releaseWakeLock(wakeLockSentinel) {
            return wakeLockSentinel.release()["catch"](function () {
              // Ignore errors.
            });
          };
          var removeReleaseEventListener = function removeReleaseEventListener(wakeLockSentinel) {
            wakeLockSentinel.onrelease = null;
          };
          var isActive = true;
          var unsubscribeWhileRequesting = function unsubscribeWhileRequesting() {
            isActive = false;
          };
          var unsubscribe = unsubscribeWhileRequesting;
          var requestWakeLock = function requestWakeLock() {
            return window.navigator.wakeLock.request(type).then(function (wakeLockSentinel) {
              if (isActive) {
                observer.next(true);
              }
              if (isActive) {
                wakeLockSentinel.onrelease = function () {
                  observer.next(false);
                  unsubscribe = unsubscribeWhileRequesting;
                  removeReleaseEventListener(wakeLockSentinel);
                  requestWakeLock();
                };
                unsubscribe = function unsubscribe() {
                  removeReleaseEventListener(wakeLockSentinel);
                  releaseWakeLock(wakeLockSentinel);
                };
              } else {
                releaseWakeLock(wakeLockSentinel);
              }
            }, function (err) {
              if (isActive) {
                observer.error(err);
              }
            });
          };
          requestWakeLock();
          return function () {
            return unsubscribe();
          };
        });
      };
    };

    // @todo TypeScript does not include type definitions for the Reporting API yet.
    var createWindow = function createWindow() {
      return typeof window === 'undefined' ? null : window;
    };

    var createWrapSubscribeFunction = function createWrapSubscribeFunction(patch, toObserver) {
      var emptyFunction = function emptyFunction() {}; // tslint:disable-line:no-empty
      var isNextFunction = function isNextFunction(args) {
        return typeof args[0] === 'function';
      };
      return function (innerSubscribe) {
        var _subscribe = function subscribe() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          var unsubscribe = innerSubscribe(isNextFunction(args) ? toObserver({
            next: args[0]
          }) : toObserver.apply(void 0, args));
          if (unsubscribe !== undefined) {
            return unsubscribe;
          }
          return emptyFunction;
        };
        _subscribe[Symbol.observable] = function () {
          return {
            subscribe: function subscribe() {
              return {
                unsubscribe: _subscribe.apply(void 0, arguments)
              };
            }
          };
        };
        return patch(_subscribe);
      };
    };

    var emitNotSupportedError = function emitNotSupportedError(observer) {
      observer.error(new Error('The required browser API seems to be not supported.'));
      return function () {}; // tslint:disable-line:no-empty
    };

    var window$1 = createWindow();
    var wrapSubscribeFunction = createWrapSubscribeFunction(rxjsInterop.patch, rxjsInterop.toObserver);
    var animationFrame = createAnimationFrame(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var mutations = createMutations(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var mapSubscribableThing = createMapSubscribableThing(wrapSubscribeFunction);
    var prependSubscribableThing = createPrependSubscribableThing(wrapSubscribeFunction);
    var attribute = createAttribute(mapSubscribableThing, mutations, prependSubscribableThing);
    var geolocation = createGeolocation(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var intersections = createIntersections(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var mediaDevices = createMediaDevices(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var mediaQueryMatch = createMediaQueryMatch(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var metrics = createMetrics(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var midiInputs = createMidiInputs(wrapSubscribeFunction);
    var midiOutputs = createMidiOutputs(wrapSubscribeFunction);
    var on = createOn(wrapSubscribeFunction);
    var online = createOnline(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var permissionState = createPermissionState(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var reports = createReports(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var resizes = createResizes(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var unhandledRejection = createUnhandledRejection(emitNotSupportedError, window$1, wrapSubscribeFunction);
    var videoFrame = createVideoFrame(emitNotSupportedError, wrapSubscribeFunction);
    var wakeLock = createWakeLock(emitNotSupportedError, window$1, wrapSubscribeFunction);

    exports.animationFrame = animationFrame;
    exports.attribute = attribute;
    exports.geolocation = geolocation;
    exports.intersections = intersections;
    exports.mediaDevices = mediaDevices;
    exports.mediaQueryMatch = mediaQueryMatch;
    exports.metrics = metrics;
    exports.midiInputs = midiInputs;
    exports.midiOutputs = midiOutputs;
    exports.mutations = mutations;
    exports.on = on;
    exports.online = online;
    exports.permissionState = permissionState;
    exports.reports = reports;
    exports.resizes = resizes;
    exports.unhandledRejection = unhandledRejection;
    exports.videoFrame = videoFrame;
    exports.wakeLock = wakeLock;

}));
